DROP TABLE "DB"."INTLIB"."EXEC_DATAUNIT_INFO";
DROP TABLE "DB"."INTLIB"."EXEC_CONTEXT_PIPELINE";
DROP TABLE "DB"."INTLIB"."EXEC_CONTEXT_DPU";
DROP TABLE "DB"."INTLIB"."EXEC_RECORD";
DROP TABLE "DB"."INTLIB"."EXEC_SCHEDULE"
DROP TABLE "DB"."INTLIB"."EXEC_SCHEDULE_AFTER"
DROP TABLE "DB"."INTLIB"."EXEC_PIPELINE";
DROP TABLE "DB"."INTLIB"."PPL_EDGE";
DROP TABLE "DB"."INTLIB"."PPL_NODE";
DROP TABLE "DB"."INTLIB"."PPL_GRAPH";
DROP TABLE "DB"."INTLIB"."PPL_MODEL";
DROP TABLE "DB"."INTLIB"."PPL_POSITION";
DROP TABLE "DB"."INTLIB"."DPU_INSTANCE";
DROP TABLE "DB"."INTLIB"."DPU_TEMPLATE";

CREATE TABLE "DB"."INTLIB"."DPU_INSTANCE"
(
-- DPURecord
  "id" INTEGER IDENTITY,
  "name" VARCHAR(45),
  "description" VARCHAR(255),
  "type" SMALLINT,
  "jar_path" VARCHAR(255),
  "configuration" LONG VARBINARY,
-- DPUInstaceRecord
  "dpu_id" INTEGER,
  PRIMARY KEY ("id")
);

CREATE TABLE "DB"."INTLIB"."DPU_TEMPLATE"
(
-- DPURecord
  "id" INTEGER IDENTITY,
  "name" VARCHAR(45),
  "description" VARCHAR(255),
  "type" SMALLINT,
  "jar_path" VARCHAR(255),
  "configuration" LONG VARBINARY,
  "parent_id" INTEGER,
-- DPUTemplateRecord
  "visibility" SMALLINT,
  "jar_description" VARCHAR(512),
  PRIMARY KEY ("id")
);

CREATE TABLE "DB"."INTLIB"."EXEC_DATAUNIT_INFO"
(
  "id" INTEGER IDENTITY,
  "name" VARCHAR(45),
  "idx" INTEGER,
  "type" SMALLINT,
  "is_input" SMALLINT,
  "exec_context_dpu_id" INTEGER,
  PRIMARY KEY ("id")
);

CREATE TABLE "DB"."INTLIB"."EXEC_CONTEXT_PIPELINE"
(
  "id" INTEGER IDENTITY,
  "directory" VARCHAR(255),
  PRIMARY KEY ("id")
);

CREATE TABLE "DB"."INTLIB"."EXEC_CONTEXT_DPU"
(
  "id" INTEGER IDENTITY,
  "exec_context_pipeline_id" INTEGER,
  "dpu_instance_id" INTEGER,
  "dummy" SMALLINT, -- TODO remove this column
  PRIMARY KEY ("id")
);

CREATE TABLE "DB"."INTLIB"."EXEC_RECORD"
(
  "id" INTEGER IDENTITY,
  "r_time" DATETIME,
  "r_type" SMALLINT,
  "dpu_id" INTEGER,
  "execution_id" INTEGER,
  "short_message" LONG VARCHAR,
  "full_message" LONG VARCHAR,
  PRIMARY KEY ("id")
);

CREATE TABLE "DB"."INTLIB"."EXEC_PIPELINE"
(
  "id" INTEGER IDENTITY,
  "status" INTEGER,
  "pipeline_id" INTEGER,
  "debug_mode" SMALLINT,
  "t_start" DATETIME,
  "t_end" DATETIME,
  "execution_directory" VARCHAR(255),
  "context_id" INTEGER,
  "schedule_id" INTEGER,
  "silent_mode" SMALLINT,
  "debugnode_id" INTEGER,
  PRIMARY KEY ("id")
);

CREATE TABLE "DB"."INTLIB"."EXEC_SCHEDULE"
(
  "id" INTEGER IDENTITY,
  "name" VARCHAR(45),
  "description" VARCHAR(255),
  "pipeline_id" INTEGER NOT NULL,
  "just_once" SMALLINT,
  "enabled" SMALLINT,
  "type" SMALLINT,
  "first_exec" DATETIME,
  "last_exec" DATETIME,
  "time_period" INTEGER,
  "period_unit" SMALLINT,
  PRIMARY KEY ("id")
);

CREATE TABLE "DB"."INTLIB"."EXEC_SCHEDULE_AFTER"
(
  "schedule_id" INTEGER,
  "pipeline_id" INTEGER,
  PRIMARY KEY ("schedule_id", "pipeline_id")
);

CREATE TABLE "DB"."INTLIB"."PPL_MODEL"
(
  "id" INTEGER IDENTITY,
  "name" VARCHAR(45),
  "description" VARCHAR(255),
  PRIMARY KEY ("id")
);

CREATE TABLE "DB"."INTLIB"."PPL_EDGE"
(
  "id" INTEGER IDENTITY,
  "graph_id" INTEGER,
  "node_from_id" INTEGER,
  "node_to_id" INTEGER,
  "data_unit_name" VARCHAR(45),
  PRIMARY KEY ("id")
);

CREATE TABLE "DB"."INTLIB"."PPL_NODE"
(
  "id" INTEGER IDENTITY,
  "graph_id" INTEGER,
  "instance_id" INTEGER,
  "position_id" INTEGER,
  PRIMARY KEY ("id")
);

CREATE TABLE "DB"."INTLIB"."PPL_GRAPH"
(
  "id" INTEGER IDENTITY,
  "pipeline_id" INTEGER,
  PRIMARY KEY ("id"),
  UNIQUE (pipeline_id)
);

CREATE TABLE "DB"."INTLIB"."PPL_POSITION"
(
  "id" INTEGER IDENTITY,
  "pos_x" INTEGER,
  "pos_y" INTEGER,
  PRIMARY KEY ("id")
);

-- CONSTRAINTS

ALTER TABLE "DB"."INTLIB"."PPL_GRAPH"
  ADD CONSTRAINT "PPL_GRAPH_PPL_MODEL_id_id" FOREIGN KEY ("pipeline_id")
    REFERENCES "DB"."INTLIB"."PPL_MODEL" ("id")
	ON UPDATE CASCADE ON DELETE CASCADE;



ALTER TABLE "DB"."INTLIB"."PPL_NODE"
  ADD CONSTRAINT "PPL_NODE_PPL_GRAPH_id_id" FOREIGN KEY ("graph_id")
    REFERENCES "DB"."INTLIB"."PPL_GRAPH" ("id")
	ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE "DB"."INTLIB"."PPL_NODE"
  ADD CONSTRAINT "PPL_NODE_DPU_INSTANCE_id_id" FOREIGN KEY ("instance_id")
    REFERENCES "DB"."INTLIB"."DPU_INSTANCE" ("id")
	ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE "DB"."INTLIB"."PPL_NODE"
  ADD CONSTRAINT "PPL_NODE_PPL_POSITION_id_id" FOREIGN KEY ("position_id")
    REFERENCES "DB"."INTLIB"."PPL_POSITION" ("id")
	ON UPDATE CASCADE ON DELETE CASCADE;



ALTER TABLE "DB"."INTLIB"."PPL_EDGE"
  ADD CONSTRAINT "PPL_EDGE_PPL_GRAPH_id_id" FOREIGN KEY ("graph_id")
    REFERENCES "DB"."INTLIB"."PPL_GRAPH" ("id")
	ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE "DB"."INTLIB"."PPL_EDGE"
  ADD CONSTRAINT "PPL_EDGE_PPL_NODE_FROM_id_id" FOREIGN KEY ("node_from_id")
    REFERENCES "DB"."INTLIB"."PPL_NODE" ("id")
	ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE "DB"."INTLIB"."PPL_EDGE"
  ADD CONSTRAINT "PPL_EDGE_PPL_NODE_TO_id_id" FOREIGN KEY ("node_to_id")
    REFERENCES "DB"."INTLIB"."PPL_NODE" ("id")
	ON UPDATE CASCADE ON DELETE CASCADE;


-- workaround for bug in virtuoso's implementation of cascades on delete
-- see https://github.com/openlink/virtuoso-opensource/issues/56
CREATE TRIGGER delete_node_fix BEFORE DELETE ON "DB"."INTLIB"."PPL_NODE" REFERENCING old AS n
{
	DELETE FROM ppl_edge
	 WHERE node_from_id = n.id
	  OR node_to_id = n.id;
};

-- TABLES FOR LOGBACK

DROP TABLE "DB"."INTLIB"."LOGGING_EVENT_PROPERTY";
DROP TABLE "DB"."INTLIB"."LOGGING_EVENT_EXCEPTION";
DROP TABLE "DB"."INTLIB"."LOGGING_EVENT";

CREATE TABLE "DB"."INTLIB"."LOGGING_EVENT"
(
  timestmp BIGINT NOT NULL,
  formatted_message LONG VARCHAR NOT NULL,
  logger_name VARCHAR(254) NOT NULL,
  level_string VARCHAR(254) NOT NULL,
  thread_name VARCHAR(254),
  reference_flag SMALLINT,
  arg0 VARCHAR(254),
  arg1 VARCHAR(254),
  arg2 VARCHAR(254),
  arg3 VARCHAR(254),
  caller_filename VARCHAR(254) NOT NULL,
  caller_class VARCHAR(254) NOT NULL,
  caller_method VARCHAR(254) NOT NULL,
  caller_line CHAR(4) NOT NULL,
  event_id BIGINT NOT NULL IDENTITY,
  PRIMARY KEY (event_id)
);

CREATE TABLE "DB"."INTLIB"."LOGGING_EVENT_PROPERTY"
(
  event_id BIGINT NOT NULL,
  mapped_key VARCHAR(254) NOT NULL,
  mapped_value VARCHAR(254),
  PRIMARY KEY (event_id, mapped_key),
  FOREIGN KEY (event_id) REFERENCES "DB"."INTLIB"."LOGGING_EVENT"(event_id)
);

CREATE TABLE "DB"."INTLIB"."LOGGING_EVENT_EXCEPTION"
(
  event_id BIGINT NOT NULL,
  i SMALLINT NOT NULL,
  trace_line VARCHAR(254) NOT NULL,
  PRIMARY KEY(event_id, i),
  FOREIGN KEY (event_id) REFERENCES "DB"."INTLIB"."LOGGING_EVENT"(event_id)
);

