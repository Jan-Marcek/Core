-- THIS FILE IS AUTOMATICALLY GENERATED BY A SCRIPT.
-- DO NOT EDIT IT MANUALLY, YOUR CHANGES WILL BE LOST!!!



CREATE TABLE `DPU_INSTANCE`
(
-- DPURecord
  `id` INTEGER AUTO_INCREMENT,
  `name` VARCHAR(45),
  `description` VARCHAR(255),
  `type` SMALLINT,
  `jar_path` VARCHAR(255),
  `configuration` BLOB,
-- DPUInstaceRecord
  `dpu_id` INTEGER,
  PRIMARY KEY (`id`)
);

CREATE TABLE `DPU_TEMPLATE`
(
-- DPURecord
  `id` INTEGER AUTO_INCREMENT,
  `name` VARCHAR(45),
  `description` VARCHAR(255),
  `type` SMALLINT,
  `jar_path` VARCHAR(255),
  `configuration` BLOB,
-- DPUTemplateRecord
  `visibility` SMALLINT,
  `jar_description` VARCHAR(512),
  PRIMARY KEY (`id`)
);

CREATE TABLE `EXEC_DATAUNIT_INFO`
(
  `id` INTEGER AUTO_INCREMENT,
  `name` VARCHAR(45),
  `idx` INTEGER,
  `type` SMALLINT,
  `is_input` SMALLINT,
  `exec_context_dpu_id` INTEGER,
  PRIMARY KEY (`id`)
);

CREATE TABLE `EXEC_CONTEXT_PIPELINE`
(
  `id` INTEGER AUTO_INCREMENT,
  `directory` VARCHAR(255),
  PRIMARY KEY (`id`)
);

CREATE TABLE `EXEC_CONTEXT_DPU`
(
  `id` INTEGER AUTO_INCREMENT,
  `exec_context_pipeline_id` INTEGER,
  `dpu_instance_id` INTEGER,
  PRIMARY KEY (`id`)
);

CREATE TABLE `EXEC_RECORD`
(
  `id` INTEGER AUTO_INCREMENT,
  `r_time` DATETIME,
  `r_type` SMALLINT,
  `dpu_id` INTEGER,
  `execution_id` INTEGER,
  `short_message` TEXT,
  `full_message` TEXT,
  PRIMARY KEY (`id`)
);

CREATE TABLE `EXEC_PIPELINE`
(
  `id` INTEGER AUTO_INCREMENT,
  `status` INTEGER,
  `pipeline_id` INTEGER,
  `debug_mode` SMALLINT,
  `t_start` DATETIME,
  `t_end` DATETIME,
  `execution_directory` VARCHAR(255),
  `context_id` INTEGER,
  `schedule_id` INTEGER,
  `silent_mode` SMALLINT,
  PRIMARY KEY (`id`)
);

CREATE TABLE `EXEC_SCHEDULE`
(
  `id` INTEGER AUTO_INCREMENT,
  `name` VARCHAR(45),
  `description` VARCHAR(255),
  `pipeline_id` INTEGER NOT NULL,
  `just_once` SMALLINT,
  `enabled` SMALLINT,
  `type` SMALLINT,
  `first_exec` DATETIME,
  `last_exec` DATETIME,
  `time_period` BIGINT,
  `period_unit` SMALLINT,
  PRIMARY KEY (`id`)
);

CREATE TABLE `EXEC_SCHEDULE_AFTER`
(
  `schedule_id` INTEGER,
  `pipeline_id` INTEGER,
  PRIMARY KEY (`schedule_id`, `pipeline_id`)
);

CREATE TABLE `PPL_MODEL`
(
  `id` INTEGER AUTO_INCREMENT,
  `name` VARCHAR(45),
  `description` VARCHAR(255),
  PRIMARY KEY (`id`)
);

CREATE TABLE `PPL_EDGE`
(
  `id` INTEGER AUTO_INCREMENT,
  `graph_id` INTEGER,
  `node_from_id` INTEGER,
  `node_to_id` INTEGER,
  PRIMARY KEY (`id`)
);

CREATE TABLE `PPL_NODE`
(
  `id` INTEGER AUTO_INCREMENT,
  `graph_id` INTEGER,
  `instance_id` INTEGER,
  `position_id` INTEGER,
  PRIMARY KEY (`id`)
);

CREATE TABLE `PPL_GRAPH`
(
  `id` INTEGER AUTO_INCREMENT,
  `pipeline_id` INTEGER,
  PRIMARY KEY (`id`),
  UNIQUE (pipeline_id)
);

CREATE TABLE `PPL_POSITION`
(
  `id` INTEGER AUTO_INCREMENT,
  `pos_x` INTEGER,
  `pos_y` INTEGER,
  PRIMARY KEY (`id`)
);

-- CONSTRAINTS

ALTER TABLE `PPL_GRAPH`
  ADD CONSTRAINT `PPL_GRAPH_PPL_MODEL_id_id` FOREIGN KEY (`pipeline_id`)
    REFERENCES `PPL_MODEL` (`id`)
	ON UPDATE CASCADE ON DELETE CASCADE;



ALTER TABLE `PPL_NODE`
  ADD CONSTRAINT `PPL_NODE_PPL_GRAPH_id_id` FOREIGN KEY (`graph_id`)
    REFERENCES `PPL_GRAPH` (`id`)
	ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE `PPL_NODE`
  ADD CONSTRAINT `PPL_NODE_DPU_INSTANCE_id_id` FOREIGN KEY (`instance_id`)
    REFERENCES `DPU_INSTANCE` (`id`)
	ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE `PPL_NODE`
  ADD CONSTRAINT `PPL_NODE_PPL_POSITION_id_id` FOREIGN KEY (`position_id`)
    REFERENCES `PPL_POSITION` (`id`)
	ON UPDATE CASCADE ON DELETE CASCADE;



ALTER TABLE `PPL_EDGE`
  ADD CONSTRAINT `PPL_EDGE_PPL_GRAPH_id_id` FOREIGN KEY (`graph_id`)
    REFERENCES `PPL_GRAPH` (`id`)
	ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE `PPL_EDGE`
  ADD CONSTRAINT `PPL_EDGE_PPL_NODE_FROM_id_id` FOREIGN KEY (`node_from_id`)
    REFERENCES `PPL_NODE` (`id`)
	ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE `PPL_EDGE`
  ADD CONSTRAINT `PPL_EDGE_PPL_NODE_TO_id_id` FOREIGN KEY (`node_to_id`)
    REFERENCES `PPL_NODE` (`id`)
	ON UPDATE CASCADE ON DELETE CASCADE;


-- workaround for bug in virtuoso's implementation of cascades on delete
-- see https://github.com/openlink/virtuoso-opensource/issues/56

-- TABLES FOR LOGBACK


CREATE TABLE `LOGGING_EVENT`
(
  timestmp BIGINT NOT NULL,
  formatted_message TEXT NOT NULL,
  logger_name VARCHAR(254) NOT NULL,
  level_string VARCHAR(254) NOT NULL,
  thread_name VARCHAR(254),
  reference_flag SMALLINT,
  arg0 VARCHAR(254),
  arg1 VARCHAR(254),
  arg2 VARCHAR(254),
  arg3 VARCHAR(254),
  caller_filename VARCHAR(254) NOT NULL,
  caller_class VARCHAR(254) NOT NULL,
  caller_method VARCHAR(254) NOT NULL,
  caller_line CHAR(4) NOT NULL,
  event_id BIGINT NOT NULL AUTO_INCREMENT,
  PRIMARY KEY (event_id)
);

CREATE TABLE `LOGGING_EVENT_PROPERTY`
(
  event_id BIGINT NOT NULL,
  mapped_key VARCHAR(254) NOT NULL,
  mapped_value TEXT,
  PRIMARY KEY (event_id, mapped_key),
  FOREIGN KEY (event_id) REFERENCES `LOGGING_EVENT`(event_id)
);

CREATE TABLE `LOGGING_EVENT_EXCEPTION`
(
  event_id BIGINT NOT NULL,
  i SMALLINT NOT NULL,
  trace_line VARCHAR(254) NOT NULL,
  PRIMARY KEY(event_id, i),
  FOREIGN KEY (event_id) REFERENCES `LOGGING_EVENT`(event_id)
);
