package cz.cuni.xrg.intlib.frontend.gui.components;

import java.text.DateFormat;
import java.text.Format;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.List;

import com.vaadin.annotations.AutoGenerated;
import com.vaadin.data.Container;
import com.vaadin.data.Item;
import com.vaadin.data.Validator;
import com.vaadin.data.Container.Filter;
import com.vaadin.data.Property;
import com.vaadin.data.Property.ValueChangeEvent;
import com.vaadin.data.Property.ValueChangeListener;
import com.vaadin.data.Validator.InvalidValueException;
import com.vaadin.data.util.BeanItem;
import com.vaadin.data.util.IndexedContainer;
import com.vaadin.event.FieldEvents;
import com.vaadin.event.FieldEvents.TextChangeEvent;
import com.vaadin.event.FieldEvents.TextChangeListener;
import com.vaadin.navigator.ViewChangeListener.ViewChangeEvent;
import com.vaadin.server.Sizeable.Unit;
import com.vaadin.shared.ui.TabIndexState;
import com.vaadin.ui.AbstractSelect;
import com.vaadin.ui.Alignment;
import com.vaadin.ui.Button;
import com.vaadin.ui.Button.ClickListener;
import com.vaadin.ui.CheckBox;
import com.vaadin.ui.ComboBox;
import com.vaadin.ui.CustomComponent;
import com.vaadin.ui.GridLayout;
import com.vaadin.ui.HorizontalLayout;
import com.vaadin.ui.InlineDateField;
import com.vaadin.ui.Label;
import com.vaadin.ui.Notification;
import com.vaadin.ui.OptionGroup;
import com.vaadin.ui.Table;
import com.vaadin.ui.TextField;
import com.vaadin.ui.TwinColSelect;
import com.vaadin.ui.VerticalLayout;
import com.vaadin.ui.AbstractTextField.TextChangeEventMode;
import com.vaadin.ui.Button.ClickEvent;

import cz.cuni.xrg.intlib.commons.app.dpu.DPUInstanceRecord;
import cz.cuni.xrg.intlib.commons.app.execution.ExecutionStatus;
import cz.cuni.xrg.intlib.commons.app.pipeline.Pipeline;
import cz.cuni.xrg.intlib.commons.app.scheduling.PeriodUnit;
import cz.cuni.xrg.intlib.commons.app.scheduling.Schedule;
import cz.cuni.xrg.intlib.commons.app.scheduling.ScheduleType;
import cz.cuni.xrg.intlib.frontend.auxiliaries.App;
import cz.cuni.xrg.intlib.frontend.auxiliaries.ContainerFactory;
import cz.cuni.xrg.intlib.frontend.gui.ViewComponent;
import cz.cuni.xrg.intlib.frontend.gui.ViewNames;
import cz.cuni.xrg.intlib.frontend.gui.components.IntlibPagedTable;
import cz.cuni.xrg.intlib.frontend.gui.views.SimpleTreeFilter;


public class SchedulePipeline extends CustomComponent {

	@AutoGenerated
	private GridLayout mainLayout;
	@AutoGenerated
	private Label label;
	private GridLayout autoLayout;
	private GridLayout afterLayout;
	
	private String  afterSelect;
	private String  automatically;
	private Container container; 
	private Container comboboxData;
	private HorizontalLayout inervalEveryLayout;
	private VerticalLayout inervalLayout;
	private TextField pipeFilter;
	private TwinColSelect selectPipe;
	private TextField tfEvery;
	private ComboBox comboEvery;
	private OptionGroup scheduleType;
	private CheckBox justOnce;
	private OptionGroup intervalOption; 
	
	private InlineDateField date;
	private Schedule schedule = null;
	
	private List<Pipeline> pipelines;
	/*- VaadinEditorProperties={"grid":"RegularGrid,20","showGrid":true,"snapToGrid":true,"snapToObject":true,"movingGuides":false,"snappingDistance":10} */

	/**
	 * The constructor should first build the main layout, set the
	 * composition root and then do any custom initialization.
	 *
	 * The constructor will not be automatically regenerated by the
	 * visual editor.
	 */
	public SchedulePipeline() {
		
		buildMainLayout();
		setCompositionRoot(mainLayout);

	}

	public void setSelectePipeline(Pipeline selectedPipeline)
	{
		comboPipeline.setValue(selectedPipeline.getId());
	}
	
	private ComboBox comboPipeline  = null;
	
	
	@AutoGenerated
	private GridLayout buildMainLayout() {
		// common part: create layout
		mainLayout = new GridLayout(2,3);
		mainLayout.setImmediate(false);
		mainLayout.setSpacing(true);
		mainLayout.setMargin(true);
		mainLayout.setWidth(800, Unit.PIXELS);

		
		container = ContainerFactory.CreatePipelines(App.getApp()
				.getPipelines().getAllPipelines());
		
		comboboxData = getComboboxData(App.getApp()
				.getPipelines().getAllPipelines());
		
		pipelines = App.getApp().getPipelines().getAllPipelines();
		
		HorizontalLayout layoutPipeline = new HorizontalLayout();
		layoutPipeline.setSpacing(true);
		layoutPipeline.setMargin(false);
				
		comboPipeline = new ComboBox();
		comboPipeline.setImmediate(true);
		comboPipeline.setContainerDataSource(container);
		comboPipeline.setNullSelectionAllowed(false);
		comboPipeline.setItemCaptionPropertyId("name");
		
		comboPipeline.addValidator(new Validator() {
			@Override
			public void validate(Object value) throws InvalidValueException {
				if (value!=null) {
					return;
				}
				throw new InvalidValueException("Pipeline must be filled!");
			}
		});
		
		comboPipeline.addValueChangeListener(new ValueChangeListener() {
			
			@Override
			public void valueChange(ValueChangeEvent event) {
				if (scheduleType.getValue().equals(ScheduleType.AFTER_PIPELINE)){
					mainLayout.removeComponent(1, 1);
					afterLayout= buildAfterLayout();
					mainLayout.addComponent(afterLayout,1,1);
				}
			}
		});

				
		layoutPipeline.addComponent(new Label("Pipeline "));		
		layoutPipeline.addComponent(comboPipeline);
		layoutPipeline.addComponent(new Label(" was selected for scheduling."));
		
		mainLayout.addComponent(layoutPipeline, 0, 0);
		

		scheduleType = new OptionGroup();
		scheduleType.setImmediate(true);
		scheduleType.addItem(ScheduleType.PERIODICALLY);
		scheduleType.addItem(ScheduleType.AFTER_PIPELINE);
		scheduleType.setValue(ScheduleType.PERIODICALLY);
		scheduleType.setItemCaption(ScheduleType.PERIODICALLY, "Schedule the pipeline to run automatically in fixed interval.");
		scheduleType.setItemCaption(ScheduleType.AFTER_PIPELINE,"Schedule the pipeline to after selected pipeline finishes.");
		scheduleType.addValueChangeListener(new ValueChangeListener() {
			
			public void valueChange(ValueChangeEvent event) {
				// TODO Auto-generated method stub
				if(event.getProperty().getValue() == ScheduleType.AFTER_PIPELINE){
					
					mainLayout.removeComponent(1, 1);
					afterLayout = buildAfterLayout();
					mainLayout.addComponent(afterLayout,1,1);
					
				}
				else{
					mainLayout.removeComponent(1, 1);
					mainLayout.addComponent(autoLayout,1,1);
				}
				
			}
		});
		
		
		mainLayout.addComponent(scheduleType,0,1);
		autoLayout = buildAutoLayout();
		mainLayout.addComponent(autoLayout,1,1);

		
		Button createRule = new Button();
		createRule.setCaption("Create scheduler rule");
		createRule.setImmediate(true);
		createRule.addClickListener(new ClickListener() {
			
			@Override
			public void buttonClick(ClickEvent event) {
				
				if ((!comboPipeline.isValid())) {
					Notification.show("Failed to create scheduler rule",
							"Mandatory fields should be filled",
							Notification.Type.ERROR_MESSAGE);
					return;
				}
				
				schedule = new Schedule();
				Object pipeID = comboPipeline.getValue();

				for (Pipeline item : pipelines) {
					if(pipeID.equals(item.getId())){
						schedule.setPipeline(item);
						break;
					}
					
				}
				schedule.setType((ScheduleType)scheduleType.getValue());
				
				//Periodically Schedule type selected
				if(scheduleType.getValue().equals(ScheduleType.PERIODICALLY)){
					schedule.setFirstExecution(date.getValue());
					schedule.setJustOnce(justOnce.getValue());
					if(justOnce.getValue().equals(false)){
						
					}
				}
				//After pipeline Schedule type selected
				else{
					
				}
				


				
				App.getApp().getSchedules().save(schedule);
				
/*				schedule.setPipeline(comboPipeline.getValue());
				schedule.setType((ScheduleType)scheduleType.getValue());
					if(scheduleType.getValue() == ScheduleType.PERIODICALLY){
						schedule.setFirstExecution(date.getValue());
						schedule.setJustOnce(justOnce.getValue());
						if(justOnce.getValue()==false){
							schedule.setPeriodUnit((PeriodUnit)intervalOption.getValue());
						}
					}*/
			}
		});
		mainLayout.addComponent(createRule,1,2);
		mainLayout.setComponentAlignment(createRule, Alignment.BOTTOM_RIGHT);		

		
		return mainLayout;
	}

	private GridLayout buildAfterLayout(){
		
		afterLayout = new GridLayout(2,1);
		afterLayout.setImmediate(false);
		afterLayout.setHeight("400px");
		afterLayout.setSpacing(true);
		
		afterLayout.setColumnExpandRatio(0, 0.2f);
		afterLayout.setColumnExpandRatio(1, 0.8f);

		
		afterLayout.addComponent(new Label("Select pipeline:"),0,0);
		
		VerticalLayout selectPipelineLayout = new VerticalLayout();
		selectPipelineLayout.setSpacing(true);
		
		pipeFilter = new TextField();
		pipeFilter.setImmediate(false);
		pipeFilter.setInputPrompt("type to filter pipelines");
		pipeFilter.setWidth("144px");
		pipeFilter.setTextChangeEventMode(TextChangeEventMode.LAZY);
		pipeFilter.addTextChangeListener(new FieldEvents.TextChangeListener() {
			SimpleTreeFilter filter = null;

			@Override
			public void textChange(FieldEvents.TextChangeEvent event) {
				selectPipe.getItemCaptionPropertyId();
				Container.Filterable f = (Container.Filterable) selectPipe.getContainerDataSource();
				

				// Remove old filter
				if (filter != null) {
					f.removeContainerFilter(filter);
				}

				// Set new filter
				filter = new SimpleTreeFilter(event.getText(), true, false);
				f.addContainerFilter(filter);

			}
		});
		
		selectPipelineLayout.addComponent(pipeFilter);


		
		
		
		selectPipe = new TwinColSelect();
		
		for (Pipeline item : pipelines) {
			if(item.getId()!=comboPipeline.getValue()){
			selectPipe.addItem(item.getName());}
			}


        selectPipe.setNullSelectionAllowed(true);
        selectPipe.setMultiSelect(true);
        selectPipe.setImmediate(true);
        selectPipe.setWidth("333px");
        selectPipe.setHeight("300px");
        selectPipe.setLeftColumnCaption("Available pipelines");
        selectPipe.setRightColumnCaption("Selected pipelines"); 
        
		selectPipelineLayout.addComponent(selectPipe);
		afterLayout.addComponent(selectPipelineLayout,1,0);
        
		return afterLayout;
		
	}
	
	private GridLayout buildAutoLayout(){
		
		autoLayout = new GridLayout(2,3);
		autoLayout.setImmediate(false);
		autoLayout.setSpacing(true);
		autoLayout.setHeight("400px");
		autoLayout.setColumnExpandRatio(0, 0.6f);
		autoLayout.setColumnExpandRatio(1, 0.4f);

		autoLayout.addComponent(new Label("Date and time of first execution:"),0,0);

		date = new InlineDateField();
		date.setValue(new java.util.Date());
		date.setResolution(date.RESOLUTION_SEC);
		autoLayout.addComponent(date,1,0);
		
		justOnce = new CheckBox();
		justOnce.setCaption("Just once");
		justOnce.setValue(false);
		justOnce.setImmediate(true);
		justOnce.addValueChangeListener(new ValueChangeListener() {
			
			@Override
			public void valueChange(ValueChangeEvent event) {
				// TODO Auto-generated method stub
				if(event.getProperty().getValue().equals(true)){
					inervalLayout.setEnabled(false);
				}
				else{
					inervalLayout.setEnabled(true);
				}
				
			}
		});
		
		autoLayout.addComponent(justOnce,1,1);
		autoLayout.addComponent(new Label("Interval:"),0,2);
		
		inervalLayout = new VerticalLayout();
		intervalOption = new OptionGroup();
		intervalOption.setImmediate(true);
		intervalOption.addItem(PeriodUnit.DAY);
		intervalOption.setItemCaption(PeriodUnit.DAY, "every day");
		intervalOption.addItem(PeriodUnit.WEEK);
		intervalOption.setItemCaption(PeriodUnit.WEEK, "every week");
		intervalOption.addItem(PeriodUnit.MONTH);
		intervalOption.setItemCaption(PeriodUnit.MONTH, "every month");
		intervalOption.addItem("every");
		intervalOption.setValue(PeriodUnit.DAY);
		intervalOption.addValueChangeListener(new ValueChangeListener() {
			
			@Override
			public void valueChange(ValueChangeEvent event) {
				// TODO Auto-generated method stub
				
				String string = event.getProperty().getValue().toString();
				if(event.getProperty().getValue().toString().equals("every")){

					comboEvery.setEnabled(true);
					tfEvery.setEnabled(true);
					
				}
				else{

					comboEvery.setEnabled(false);
					tfEvery.setEnabled(false);
				}
				
			}
		});
		inervalLayout.addComponent(intervalOption);

		
		inervalEveryLayout = new HorizontalLayout();
		inervalEveryLayout.setSpacing(true);
		inervalEveryLayout.setMargin(true);
		
		tfEvery = new TextField();
		tfEvery.setWidth("50px");
		tfEvery.setImmediate(true);
		tfEvery.setEnabled(false);
		
		inervalEveryLayout.addComponent(tfEvery);
		
		comboEvery = new ComboBox();
		comboEvery.setNullSelectionAllowed(false);
		comboEvery.setImmediate(true);
		comboEvery.addItem(PeriodUnit.MINUTE);
		comboEvery.setItemCaption(PeriodUnit.MINUTE, "Minutes");
		comboEvery.addItem(PeriodUnit.HOUR);
		comboEvery.setItemCaption(PeriodUnit.HOUR, "Hours");
		comboEvery.addItem(PeriodUnit.DAY);
		comboEvery.setItemCaption(PeriodUnit.DAY, "Days");
		comboEvery.addItem(PeriodUnit.MONTH);
		comboEvery.setItemCaption(PeriodUnit.MONTH, "Months");
		comboEvery.setValue(PeriodUnit.DAY);
		comboEvery.setEnabled(false);

		inervalEveryLayout.addComponent(comboEvery);
		inervalLayout.addComponent(inervalEveryLayout);
		autoLayout.addComponent(inervalLayout,1,2);
		
		return autoLayout;
		
	}
	
	public static IndexedContainer getComboboxData(List<Pipeline> data) {

		IndexedContainer result = new IndexedContainer();
		result.addContainerProperty("name", String.class, "");

		for (Pipeline item : data){	
			Object num = result.addItem();
			result.getContainerProperty(num, "name").setValue(item.getName());
	
		}

		return result;
	}
	
	
	class actionColumnGenerator implements com.vaadin.ui.Table.ColumnGenerator {

		@Override
		public Object generateCell(final Table source, final Object itemId,
				Object columnId) {
			HorizontalLayout layout = new HorizontalLayout();

			CheckBox selectPipe = new CheckBox();
			layout.addComponent(selectPipe);
			// get item
	
			return layout;
		}

	}


	public void resize(float height) {
		float newLogHeight = height - 325;
		if(newLogHeight < 400) {
			newLogHeight = 400;
		}

	}

}

