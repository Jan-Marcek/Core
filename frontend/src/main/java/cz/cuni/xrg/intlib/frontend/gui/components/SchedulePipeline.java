package cz.cuni.xrg.intlib.frontend.gui.components;

import java.text.DateFormat;
import java.text.Format;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Date;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Set;

import com.vaadin.annotations.AutoGenerated;
import com.vaadin.data.Container;
import com.vaadin.data.Item;
import com.vaadin.data.Validator;
import com.vaadin.data.Container.Filter;
import com.vaadin.data.Property;
import com.vaadin.data.Property.ValueChangeEvent;
import com.vaadin.data.Property.ValueChangeListener;
import com.vaadin.data.Validator.InvalidValueException;
import com.vaadin.data.util.BeanItem;
import com.vaadin.data.util.IndexedContainer;
import com.vaadin.data.util.ObjectProperty;
import com.vaadin.data.util.converter.Converter.ConversionException;
import com.vaadin.event.FieldEvents;
import com.vaadin.event.FieldEvents.TextChangeEvent;
import com.vaadin.event.FieldEvents.TextChangeListener;
import com.vaadin.navigator.ViewChangeListener.ViewChangeEvent;
import com.vaadin.server.Sizeable.Unit;
import com.vaadin.shared.ui.TabIndexState;
import com.vaadin.ui.AbstractSelect;
import com.vaadin.ui.Alignment;
import com.vaadin.ui.Button;
import com.vaadin.ui.Button.ClickListener;
import com.vaadin.ui.CheckBox;
import com.vaadin.ui.ComboBox;
import com.vaadin.ui.CustomComponent;
import com.vaadin.ui.GridLayout;
import com.vaadin.ui.HorizontalLayout;
import com.vaadin.ui.InlineDateField;
import com.vaadin.ui.Label;
import com.vaadin.ui.Notification;
import com.vaadin.ui.OptionGroup;
import com.vaadin.ui.Table;
import com.vaadin.ui.TextField;
import com.vaadin.ui.TwinColSelect;
import com.vaadin.ui.VerticalLayout;
import com.vaadin.ui.AbstractTextField.TextChangeEventMode;
import com.vaadin.ui.Button.ClickEvent;
import com.vaadin.ui.Window;

import cz.cuni.xrg.intlib.commons.app.dpu.DPUInstanceRecord;
import cz.cuni.xrg.intlib.commons.app.execution.ExecutionStatus;
import cz.cuni.xrg.intlib.commons.app.pipeline.Pipeline;
import cz.cuni.xrg.intlib.commons.app.scheduling.PeriodUnit;
import cz.cuni.xrg.intlib.commons.app.scheduling.Schedule;
import cz.cuni.xrg.intlib.commons.app.scheduling.ScheduleType;
import cz.cuni.xrg.intlib.frontend.auxiliaries.App;
import cz.cuni.xrg.intlib.frontend.auxiliaries.ContainerFactory;
import cz.cuni.xrg.intlib.frontend.gui.ViewComponent;
import cz.cuni.xrg.intlib.frontend.gui.ViewNames;
import cz.cuni.xrg.intlib.frontend.gui.components.IntlibPagedTable;
import cz.cuni.xrg.intlib.frontend.gui.views.SimpleTreeFilter;

/**
 *  Dialog for the scheduling rule creation. Called from the {@link #Scheduler} 
 *  and {@link #PipelineEdit}. Designed for setting the description of when the pipeline
 *  should be executed.
 * 
 * @author Maria Kukhar
 *
 */
public class SchedulePipeline extends Window {

	@AutoGenerated
	private GridLayout mainLayout;
	@AutoGenerated
	private Label label;
	private GridLayout autoLayout;
	private GridLayout afterLayout;

	private String afterSelect;
	private String automatically;
	private Container container;
	private HorizontalLayout inervalEveryLayout;
	private VerticalLayout inervalLayout;
	private TextField pipeFilter;
	private TwinColSelect selectPipe;
	private TextField tfEvery;
	private ComboBox comboEvery;
	private OptionGroup scheduleType;
	private CheckBox justOnce;
	private OptionGroup intervalOption;

	private InlineDateField date;
	private Schedule schedule = null;
	private ObjectProperty<Integer> value;

	private List<Pipeline> pipelines;
	private Set<Pipeline> afterPipelines = null;
	private Schedule selectSch = null;

	/*- VaadinEditorProperties={"grid":"RegularGrid,20","showGrid":true,"snapToGrid":true,"snapToObject":true,"movingGuides":false,"snappingDistance":10} */

	/**
	 * The constructor should first build the main layout, set the composition
	 * root and then do any custom initialization.
	 * 
	 * The constructor will not be automatically regenerated by the visual
	 * editor.
	 */
	public SchedulePipeline() {
		this.setResizable(false);
		this.setModal(true);
		this.setCaption("Schedule a pipeline");

		buildMainLayout();
		this.setContent(mainLayout);
		setSizeUndefined();

	}

	/**
	 * The method calls from {@link #PipelineEdit} and sets the corresponding 
	 * value of Pipeline component to the dialog.
	 * 
	 * @param selectedPipeline. Pipeline that locate in the row of Pipeline List table 
	 * in which has been pressed the button Scheduler.
	 */
	public void setSelectePipeline(Pipeline selectedPipeline) {
		comboPipeline.setValue(selectedPipeline.getId());
	}

	private ComboBox comboPipeline = null;

	/**
	 * The method calls from {@link #Scheduler} and sets the corresponding 
	 * values of specific scheduling rule parameters to the dialog.
	 * 
	 * @param selectedSchedule. Schedule that locate in the row of Schedule table 
	 * in which has been pressed the button Scheduler.
	 */
	public void setSelectedSchedule(Schedule selectedSchedule)
	{	
		//setting pipeline
		comboPipeline.setValue(selectedSchedule.getPipeline().getId());
		//setting scheduling rule type
		scheduleType.setValue(selectedSchedule.getType());
		//PERIODICALLY type
		if (selectedSchedule.getType().equals(ScheduleType.PERIODICALLY)) {
			//setting the date
			date.setValue(selectedSchedule.getFirstExecution());
			//setting just ones parameter
			if (selectedSchedule.isJustOnce()){
				justOnce.setValue(true);

			}
			//setting period of repeat
			else{
				if (((selectedSchedule.getPeriodUnit().equals(PeriodUnit.DAY))
						|| (selectedSchedule.getPeriodUnit()
								.equals(PeriodUnit.WEEK)) || (selectedSchedule
							.getPeriodUnit().equals(PeriodUnit.MONTH)))
						&& (selectedSchedule.getPeriod().equals(1))) {
					intervalOption.setValue(selectedSchedule.getPeriodUnit());
				}
				else{
					intervalOption.setValue("every");
					comboEvery.setValue(selectedSchedule.getPeriodUnit());
					value.setValue(selectedSchedule.getPeriod());
				}
				
			}
			
		}
		//AFTER_PIPELINE type
		else{
			//setting after_pipeline list 
			Set<Pipeline> after = selectedSchedule.getAfterPipelines();
			List<String> afterNames = new ArrayList<String>();
			  for (Pipeline afteritem : after){
				  afterNames.add(afteritem.getName());
			  }
			
			
			selectPipe.setValue(afterNames);
			
		}
		
		selectSch = selectedSchedule;

	}

	/**
	 * Builds main layout. Contains pipeline, pipeline type, layouts with components for 
	 * setting each of the type.
	 */
	@AutoGenerated
	private GridLayout buildMainLayout() {
		// common part: create layout
		mainLayout = new GridLayout(2, 3);
		mainLayout.setImmediate(false);
		mainLayout.setSpacing(true);
		mainLayout.setMargin(true);
		mainLayout.setWidth(850, Unit.PIXELS);

		container = ContainerFactory.CreatePipelines(App.getApp()
				.getPipelines().getAllPipelines());

		pipelines = App.getApp().getPipelines().getAllPipelines();

		HorizontalLayout layoutPipeline = new HorizontalLayout();
		layoutPipeline.setSpacing(true);
		layoutPipeline.setMargin(false);
		
		//Pipeline component
		comboPipeline = new ComboBox();
		comboPipeline.setImmediate(true);
		comboPipeline.setContainerDataSource(container);
		comboPipeline.setNullSelectionAllowed(false);
		comboPipeline.setItemCaptionPropertyId("name");
		//setting mandatory for the pipeline component
		comboPipeline.addValidator(new Validator() {
			@Override
			public void validate(Object value) throws InvalidValueException {
				if (value != null) {
					return;
				}
				throw new InvalidValueException("Pipeline must be filled!");
			}
		});

		comboPipeline.addValueChangeListener(new ValueChangeListener() {

			/**
			 * If scheduling type is AFTER_PIPELINE, then refreshing list of pipelines
			 * in the after_pipeline component. It should not contain selected for
			 * scheduling pipeline.
			 */
			private static final long serialVersionUID = 1L;

			@Override
			public void valueChange(ValueChangeEvent event) {
				if (scheduleType.getValue().equals(ScheduleType.AFTER_PIPELINE)) {
					mainLayout.removeComponent(1, 1);
					afterLayout = buildAfterLayout();
					mainLayout.addComponent(afterLayout, 1, 1);
				}
			}
		});

		layoutPipeline.addComponent(new Label("Pipeline "));
		layoutPipeline.addComponent(comboPipeline);
		layoutPipeline.addComponent(new Label(" was selected for scheduling."));

		mainLayout.addComponent(layoutPipeline, 0, 0);
		
		//Schedule type component. Two types: PERIODICALLY and AFTER_PIPELINE
		scheduleType = new OptionGroup();
		scheduleType.setImmediate(true);
		scheduleType.addItem(ScheduleType.PERIODICALLY);
		scheduleType.addItem(ScheduleType.AFTER_PIPELINE);
		scheduleType.setValue(ScheduleType.PERIODICALLY);
		scheduleType
				.setItemCaption(ScheduleType.PERIODICALLY,
						"Schedule the pipeline to run automatically in fixed interval.");
		scheduleType.setItemCaption(ScheduleType.AFTER_PIPELINE,
				"Schedule the pipeline to after selected pipeline finishes.");
		scheduleType.addValueChangeListener(new ValueChangeListener() {

			/**
			 * For each type will be shown corresponding layout with components 
			 * for scheduling rule settings.
			 */
			private static final long serialVersionUID = 1L;

			public void valueChange(ValueChangeEvent event) {
				
				if (event.getProperty().getValue() == ScheduleType.AFTER_PIPELINE) {

					mainLayout.removeComponent(1, 1);
					afterLayout = buildAfterLayout();
					mainLayout.addComponent(afterLayout, 1, 1);

				} else {
					mainLayout.removeComponent(1, 1);
					mainLayout.addComponent(autoLayout, 1, 1);
				}

			}
		});

		mainLayout.addComponent(scheduleType, 0, 1);
		autoLayout = buildAutoLayout();
		mainLayout.addComponent(autoLayout, 1, 1);
		
		//Save button
		Button createRule = new Button();
		createRule.setCaption("Save scheduler rule");
		createRule.setImmediate(true);
		createRule.addClickListener(new ClickListener() {

			/**
			 * Checks validation of mandatory fields. Gets settings of scheduling rule 
			 * and store record to the Database.
			 */
			private static final long serialVersionUID = 1L;

			@Override
			public void buttonClick(ClickEvent event) {
				//validation
				//pipeline should be filled
				if (!comboPipeline.isValid()) {
					Notification.show("Failed to create scheduler rule.",
							"Mandatory fields should be filled",
							Notification.Type.ERROR_MESSAGE);
					return;
				}
				//Interval of PERIODICALLY type should be positive number
				if ((scheduleType.getValue().equals(ScheduleType.PERIODICALLY))
						&& (!tfEvery.isValid())) {
					Notification.show("Failed to create scheduler rule.",
							"Interval value error",
							Notification.Type.ERROR_MESSAGE);
					return;
				}
				//selected pipeline in the AFTER_PIPELINE case should be filled.
				if ((scheduleType.getValue()
						.equals(ScheduleType.AFTER_PIPELINE))
						&& (!selectPipe.isValid())) {
					Notification.show("Failed to create scheduler rule.",
							"Mandatory fields should be filled",
							Notification.Type.ERROR_MESSAGE);
					return;
				}

				
				//checking if the dialog was open from the Scheduler table
				//if no, create new scheduling rule
				if (selectSch== null){
					schedule = new Schedule();
				}
				else{
					schedule = selectSch;
					selectSch = null;
				}
				
				Object pipeID = comboPipeline.getValue();
				
				//setting scheduler parameters
				//setting pipeline
				for (Pipeline item : pipelines) {
					if (pipeID.equals(item.getId())) {
						schedule.setPipeline(item);
						break;
					}

				}
				//setting type
				schedule.setType((ScheduleType) scheduleType.getValue());

				// Periodically Schedule type selected. Setting parameters.
				if (scheduleType.getValue().equals(ScheduleType.PERIODICALLY)) {
					schedule.setFirstExecution(date.getValue());
					schedule.setJustOnce(justOnce.getValue());
					if (justOnce.getValue().equals(false)) {

						if ((intervalOption.getValue().equals(PeriodUnit.DAY))
								|| (intervalOption.getValue()
										.equals(PeriodUnit.WEEK))
								|| (intervalOption.getValue()
										.equals(PeriodUnit.MONTH))) {

							schedule.setPeriodUnit((PeriodUnit) intervalOption
									.getValue());
							schedule.setPeriod(1);

						} else {
							schedule.setPeriodUnit((PeriodUnit) comboEvery
									.getValue());
							schedule.setPeriod(value.getValue());
						}
					}
					
				}
				// After pipeline Schedule type selected Setting parameters.
				else {
					Set<Object> selectedPipelines = (Set) selectPipe.getValue();
					Iterator<Object> it = selectedPipelines.iterator();
					afterPipelines = new HashSet<Pipeline>();
					while (it.hasNext()) {
						Object selectPipe = it.next();
						for (Pipeline item : pipelines) {
							if (item.getName().equals(selectPipe)) {
								afterPipelines.add(item);
							}
						}

					}

					schedule.setAfterPipelines(afterPipelines);
					schedule.setJustOnce(true);
					schedule.setFirstExecution(null);
					schedule.setPeriodUnit(null);
					schedule.setPeriod(null);
				}
				schedule.setEnabled(true);
				
				// store scheduling rule record to DB
				App.getApp().getSchedules().save(schedule);
				close();

			}
		});
		mainLayout.addComponent(createRule, 1, 2);
		mainLayout.setComponentAlignment(createRule, Alignment.BOTTOM_RIGHT);

		return mainLayout;
	}

	/**
	 * Building layout for the AFTER_PIPELINE type.
	 */
	private GridLayout buildAfterLayout() {

		afterLayout = new GridLayout(2, 1);
		afterLayout.setImmediate(false);
		afterLayout.setHeight("400px");
		afterLayout.setSpacing(true);

		afterLayout.setColumnExpandRatio(0, 0.2f);
		afterLayout.setColumnExpandRatio(1, 0.8f);

		afterLayout.addComponent(new Label("Select pipeline:"), 0, 0);

		VerticalLayout selectPipelineLayout = new VerticalLayout();
		selectPipelineLayout.setSpacing(true);

		pipeFilter = new TextField();
		pipeFilter.setImmediate(false);
		pipeFilter.setInputPrompt("type to filter pipelines");
		pipeFilter.setWidth("144px");
		pipeFilter.setTextChangeEventMode(TextChangeEventMode.LAZY);
		pipeFilter.addTextChangeListener(new FieldEvents.TextChangeListener() {
			/**
			 * Filtering by pipeline name in the selectPipe component.
			 */
			private static final long serialVersionUID = 1L;
			SimpleTreeFilter filter = null;

			@Override
			public void textChange(FieldEvents.TextChangeEvent event) {
				selectPipe.getItemCaptionPropertyId();
				Container.Filterable f = (Container.Filterable) selectPipe
						.getContainerDataSource();

				// Remove old filter
				if (filter != null) {
					f.removeContainerFilter(filter);
				}

				// Set new filter
				filter = new SimpleTreeFilter(event.getText(), true, false);
				f.addContainerFilter(filter);

			}
		});

		selectPipelineLayout.addComponent(pipeFilter);
		
		//Component for pipelines select
		selectPipe = new TwinColSelect();
		//getting all pipelines to the left column
		for (Pipeline item : pipelines) {
			if (item.getId() != comboPipeline.getValue()) {
				selectPipe.addItem(item.getName());
			}
		}

		selectPipe.setNullSelectionAllowed(true);
		selectPipe.setMultiSelect(true);
		selectPipe.setImmediate(true);
		selectPipe.setWidth("333px");
		selectPipe.setHeight("300px");
		selectPipe.setLeftColumnCaption("Available pipelines");
		selectPipe.setRightColumnCaption("Selected pipelines");
		//selectPipe is mandatory component 
		selectPipe.addValidator(new Validator() {

			@Override
			public void validate(Object value) throws InvalidValueException {
				String s = value.toString();

				if (value.toString() != "[]") {
					return;
				}
				throw new InvalidValueException(
						"Selected pipeline must be filled!");

			}
		});

		selectPipelineLayout.addComponent(selectPipe);
		afterLayout.addComponent(selectPipelineLayout, 1, 0);

		return afterLayout;

	}
	
	/**
	 * Building layout for the PERIODICALLY type.
	 */
	private GridLayout buildAutoLayout() {

		autoLayout = new GridLayout(2, 3);
		autoLayout.setImmediate(false);
		autoLayout.setSpacing(true);
		autoLayout.setHeight("400px");
		autoLayout.setColumnExpandRatio(0, 0.6f);
		autoLayout.setColumnExpandRatio(1, 0.4f);
		
		//Date component
		autoLayout.addComponent(new Label("Date and time of first execution:"),
				0, 0);

		date = new InlineDateField();
		date.setValue(new java.util.Date());
		date.setResolution(date.RESOLUTION_SEC);
		autoLayout.addComponent(date, 1, 0);
		
		//Just ones component. Used if the pipeline will be run only ones
		justOnce = new CheckBox();
		justOnce.setCaption("Just once");
		justOnce.setValue(false);
		justOnce.setImmediate(true);
		justOnce.addValueChangeListener(new ValueChangeListener() {

			/**
			 * If justOnce is selected then the OptionGroup inervalLayout is disabled.
			 */
			private static final long serialVersionUID = 1L;

			@Override
			public void valueChange(ValueChangeEvent event) {
				if (event.getProperty().getValue().equals(true)) {
					inervalLayout.setEnabled(false);
					if (!tfEvery.isValid()) {
						tfEvery.setValue("1");
					}
				} else {
					inervalLayout.setEnabled(true);
				}

			}
		});

		autoLayout.addComponent(justOnce, 1, 1);
		autoLayout.addComponent(new Label("Interval:"), 0, 2);
		
		//OptionGroup with an interval 
		inervalLayout = new VerticalLayout();
		intervalOption = new OptionGroup();
		intervalOption.setImmediate(true);
		intervalOption.addItem(PeriodUnit.DAY);
		intervalOption.setItemCaption(PeriodUnit.DAY, "every day");
		intervalOption.addItem(PeriodUnit.WEEK);
		intervalOption.setItemCaption(PeriodUnit.WEEK, "every week");
		intervalOption.addItem(PeriodUnit.MONTH);
		intervalOption.setItemCaption(PeriodUnit.MONTH, "every month");
		intervalOption.addItem("every");
		intervalOption.setValue(PeriodUnit.DAY);
		intervalOption.addValueChangeListener(new ValueChangeListener() {

			/**
			 * If selected "every" then will be enable component for setting nonstandard
			 * interval.
			 */
			private static final long serialVersionUID = 1L;

			@Override
			public void valueChange(ValueChangeEvent event) {

				if (event.getProperty().getValue().toString().equals("every")) {

					comboEvery.setEnabled(true);
					tfEvery.setEnabled(true);

				} else {

					comboEvery.setEnabled(false);
					if (!tfEvery.isValid()) {
						tfEvery.setValue("1");
					}
					tfEvery.setEnabled(false);
				}

			}
		});
		inervalLayout.addComponent(intervalOption);
		
		//layout for the component for setting nonstandard interval.
		//contains text field for setting numbers and combobox with period values.
		inervalEveryLayout = new HorizontalLayout();
		inervalEveryLayout.setSpacing(true);
		inervalEveryLayout.setMargin(true);

		value = new ObjectProperty<Integer>(1);
		tfEvery = new TextField(value);
		tfEvery.setConverter(Integer.class);
		tfEvery.setWidth("50px");
		tfEvery.setImmediate(true);
		tfEvery.setEnabled(false);
		tfEvery.addValidator(new Validator() {

			@Override
			public void validate(Object val) throws InvalidValueException {
				if (((Integer) val != null) && ((Integer) val > 0)) {
					return;
				}
				throw new InvalidValueException("Value must be positive");

			}
		});

		inervalEveryLayout.addComponent(tfEvery);

		comboEvery = new ComboBox();
		comboEvery.setNullSelectionAllowed(false);
		comboEvery.setImmediate(true);
		comboEvery.addItem(PeriodUnit.MINUTE);
		comboEvery.setItemCaption(PeriodUnit.MINUTE, "Minutes");
		comboEvery.addItem(PeriodUnit.HOUR);
		comboEvery.setItemCaption(PeriodUnit.HOUR, "Hours");
		comboEvery.addItem(PeriodUnit.DAY);
		comboEvery.setItemCaption(PeriodUnit.DAY, "Days");
		comboEvery.addItem(PeriodUnit.MONTH);
		comboEvery.setItemCaption(PeriodUnit.MONTH, "Months");
		comboEvery.setValue(PeriodUnit.DAY);
		comboEvery.setEnabled(false);

		inervalEveryLayout.addComponent(comboEvery);
		inervalLayout.addComponent(inervalEveryLayout);
		autoLayout.addComponent(inervalLayout, 1, 2);

		return autoLayout;

	}

}
