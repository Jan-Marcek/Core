package cz.cuni.mff.xrg.odcs.frontend.gui.components;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Set;

import org.springframework.beans.factory.annotation.Autowired;

import com.vaadin.annotations.AutoGenerated;
import com.vaadin.data.Container;
import com.vaadin.data.Validator;
import com.vaadin.ui.Alignment;
import com.vaadin.ui.Button;
import com.vaadin.ui.Button.ClickListener;
import com.vaadin.ui.HorizontalLayout;
import com.vaadin.ui.Notification;
import com.vaadin.ui.TwinColSelect;
import com.vaadin.ui.VerticalLayout;
import com.vaadin.ui.Window;
import com.vaadin.ui.Button.ClickEvent;

import cz.cuni.mff.xrg.odcs.commons.app.facade.PipelineFacade;
import cz.cuni.mff.xrg.odcs.commons.app.pipeline.DbPipeline;
import cz.cuni.mff.xrg.odcs.commons.app.pipeline.Pipeline;
import cz.cuni.mff.xrg.odcs.commons.app.scheduling.ScheduleType;
import cz.cuni.mff.xrg.odcs.frontend.container.ReadOnlyContainer;
import cz.cuni.mff.xrg.odcs.frontend.container.accessor.PipelineNameAccessor;
import cz.cuni.mff.xrg.odcs.frontend.doa.container.InMemorySource;

/**
 * Dialog for pipeline conflict creation. Called from the {@link #PipelineEdit}.
 *
 * @author Maria Kukhar
 *
 */
public class PipelineConflicts extends Window {

	private static final long serialVersionUID = 1L;
	private VerticalLayout mainLayout;
	private Container container;
	@Autowired
	private DbPipeline dbPipeline;
	private TwinColSelect selectPipe;
	private Button clearConflicts;
	private boolean isInitialized = false;
	private Set<Pipeline> conflictPipelines = null;
	@Autowired
	private PipelineFacade pipelineFacade;

	/**
	 * The constructor should first build the main layout, set the composition
	 * root and then do any custom initialization.
	 *
	 * The constructor will not be automatically regenerated by the visual
	 * editor.
	 */
	public PipelineConflicts() {
		this.setResizable(false);
		this.setModal(true);
		this.setCaption("Pipeline Conflicts");
	}
	
	public void init(Pipeline pipeline) {
		buildMainLayout(pipeline);
		this.setContent(mainLayout);
		setSizeUndefined();
		isInitialized = true;
		
		Set<Pipeline> conflicts = pipeline.getConflicts();
		List<Long> conflictsNames = new ArrayList<>();
		for (Pipeline conflictitem : conflicts) {
			conflictsNames.add(conflictitem.getId());
		}
		selectPipe.setValue(conflictsNames);
	}
	
	public boolean isInitialized() {
		return isInitialized;
	}

	/**
	 * Builds main layout
	 *
	 * @return mainLayout VerticalLayout with all dialog components
	 */
	@AutoGenerated
	private VerticalLayout buildMainLayout(final Pipeline pipeline) {

		mainLayout = new VerticalLayout();
		mainLayout.setImmediate(false);
		mainLayout.setMargin(true);
		mainLayout.setSpacing(true);
		mainLayout.setWidth("435px");

	
		container = new ReadOnlyContainer<>(
				new InMemorySource<>(new PipelineNameAccessor(), dbPipeline));

		//Component for pipelines select
		selectPipe = new TwinColSelect();
		selectPipe.setContainerDataSource(container);
		selectPipe.setNullSelectionAllowed(true);
		selectPipe.setMultiSelect(true);
		selectPipe.setImmediate(true);
		selectPipe.setWidth("400px");
		selectPipe.setHeight("200px");
		selectPipe.setItemCaptionPropertyId("name");
		selectPipe.setLeftColumnCaption("Pipeline list");
		selectPipe.setRightColumnCaption("Conflict pipelines");
		//selectPipe is mandatory component 
		selectPipe.addValidator(new Validator() {
			private static final long serialVersionUID = 1L;
			
			@Override
			public void validate(Object value) throws InvalidValueException {
				
				if (!value.toString().equals("[]")) {
					return;
				}
				throw new InvalidValueException(
						"Conflicts pipeline must be filled!");
				
			}
		});
		

		mainLayout.addComponent(selectPipe);
		
		clearConflicts = new Button("Clear Conflicts");
		clearConflicts.setImmediate(true);
		clearConflicts.addClickListener(new ClickListener() {

			private static final long serialVersionUID = 1L;

			@Override
			public void buttonClick(ClickEvent event) {

				selectPipe.setValue(null);
				
			}
		});
		mainLayout.addComponent(clearConflicts);
		mainLayout.setComponentAlignment(clearConflicts, Alignment.MIDDLE_RIGHT);
		
		//Layout with buttons Save and Cancel
		HorizontalLayout buttonBar = new HorizontalLayout();

		//Save button
		Button saveButton = new Button();
		saveButton.setCaption("OK");
		saveButton.setWidth("90px");
		saveButton.setImmediate(true);
		saveButton.addClickListener(new ClickListener() {

			private static final long serialVersionUID = 1L;

			@Override
			public void buttonClick(ClickEvent event) {
				if (!selectPipe.isValid()) {
					Notification.show("Conflicts pipeline must be filled!",
							Notification.Type.ERROR_MESSAGE);
					return;
				}
				
				Set<Object> selectedPipelines = (Set) selectPipe.getValue();
				Iterator<Object> it = selectedPipelines.iterator();	
				
				Set<Pipeline> conflicts = pipeline.getConflicts();
				conflicts.clear();
				
				conflicts = new HashSet<>();
				while (it.hasNext()) {
					Object selectPipe = it.next();
					Pipeline item = pipelineFacade.getPipeline((Long) selectPipe);
					conflicts.add(item);
				}

				close();
			}
			
						
		});
		buttonBar.addComponent(saveButton);
		
		//Cancel button
		Button cancelButton = new Button("Cancel", new Button.ClickListener() {
			private static final long serialVersionUID = 1L;
			
			@Override
			public void buttonClick(Button.ClickEvent event) {
				close();
				
			}
		});
		cancelButton.setWidth("90px");
		cancelButton.setImmediate(true);
		buttonBar.addComponent(cancelButton);

		mainLayout.addComponent(buttonBar);

		return mainLayout;
	}


}
